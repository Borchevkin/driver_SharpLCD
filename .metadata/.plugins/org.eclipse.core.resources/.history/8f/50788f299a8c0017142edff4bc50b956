#include <stdbool.h>
#include <stdint.h>
#include "em_device.h"
#include "em_chip.h"
#include "em_gpio.h"
#include "em_cmu.h"
#include "em_usart.h"
#include "InitDevice.h"
#include "sharpLCD.h"
#include "bsp.h"
#include "font.h"

sharplcd_t sharplcd;

/* =============TEST FIELD============= */

unsigned char LineBuff[SHARPLCD_XRES/8];

char TextBuff[9];

/* ==================================== */

/* =====Counts 1ms timeTicks===== */
volatile uint32_t msTicks = 0;

/* =====Interrupt Handlers Section===== */
void SysTick_Handler(void)
{
	msTicks++;
}

/* =====================Main Section===================== */
int main(void)
{
	// Chip errata
	CHIP_Init();
	enter_DefaultMode_from_RESET();

	SysTick_Config(CMU_ClockFreqGet(cmuClock_CORE) / 1000);

	// Init Display
	sharplcd.Write = SPI1_SendPacket;
	sharplcd.SetCS = DISPLAY_SetCS;
	sharplcd.ClearCS = DISPLAY_ClearCS;
	sharplcd.SetVCOM = DISPLAY_SetVCOM;
	sharplcd.ClearVCOM = DISPLAY_ClearVCOM;
	//sharplcd.GetVCOM = DISPLAY_GetVCOM;
	sharplcd.SetDISP = DISPLAY_SetDISP;
	sharplcd.ClearDISP = DISPLAY_ClearDISP;
	sharplcd.SetLSBFirst = SPI1_SetLSBFirst;
	sharplcd.SetMSBFirst = SPI1_SetMSBFirst;
	sharplcd.DelayMs = Delay;
	SHARPLCD_Init(&sharplcd);

	//Set Display ON
	DISPLAY_SetDISP();

	while (1)
	{
		//Straight line
		uint8_t line_1[12] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

		//LEDs
		GPIO_PinOutToggle(LED0_PORT, LED0_PIN);
		GPIO_PinOutToggle(LED1_PORT, LED1_PIN);

		// ========== Test Field

		SHARPLCD_WriteLine(&sharplcd, 0, line_1);
		Delay(1000);
		SHARPLCD_WriteLine(&sharplcd, 1, line_1);
		Delay(1000);
		SHARPLCD_WriteLine(&sharplcd, 2, line_1);
		Delay(1000);
		SHARPLCD_WriteLine(&sharplcd, 3, line_1);
		Delay(1000);
		SHARPLCD_WriteLine(&sharplcd, 4, line_1);
		Delay(1000);
		SHARPLCD_WriteLine(&sharplcd, 5, line_1);
		Delay(1000);
		SHARPLCD_WriteLine(&sharplcd, 6, line_1);
		Delay(1000);
		SHARPLCD_Clear(&sharplcd);
		Delay(1000);
	}
}
/* ============================================================ */




/* =============TEST FIELD============= */

void printSharp(const char* text, unsigned char line, unsigned char options)
{
	// c = char
	// b = bitmap
	// i = text index
	// j = line buffer index
	// k = char line
	unsigned char c, b, i, j, k;

	// rendering happens line-by-line because this display can only be written by line
	k = 0;
	while(k < 8 && line < SHARPLCD_YRES)						// loop for 8 character lines while within display
	{
		i = 0;
		j = 0;
		while(j < (SHARPLCD_XRES/8) && (c = text[i]) != 0)	// while we did not reach end of line or string
		{
			if(c < ' ' || c > 'Z')						// invalid characters are replace with SPACE
			{
				c = ' ';
			}

			c = c - 32;									// convert character to index in font table
			b = font8x8[(c*8)+k];						// retrieve byte defining one line of character

			if(!(options & 1))				// invert bits if DISP_INVERT is _NOT_ selected
			{											// pixels are LOW active
				b = ~b;
			}

			if((options & 2) && (c != 0))		// double width rendering if DISP_WIDE and character is not SPACE
			{
				doubleWideAsm(b, &LineBuff[j]);			// implemented in assembly for efficiency/space reasons
				j += 2;									// we've written two bytes to buffer
			}
			else										// else regular rendering
			{
				LineBuff[j] = b;						// store pixels in line buffer
				j++;									// we've written one byte to buffer
			}

			i++;										// next character
		}

		while(j < (SHARPLCD_XRES/8))							// pad line for empty characters
		{
			LineBuff[j] = 0xff;
			j++;
		}

		SPIWriteLine(line++);							// write line buffer

		if(options & 4 && line < SHARPLCD_YRES)	// repeat line if DISP_HIGH is selected
		{
			SPIWriteLine(line++);
		}

		k++;											// next pixel line
	}
}

/* ==================================== */

